function plotAsSelected() {
  var tab_idx = $('#sensor_sel_tabs').tabs('option', 'selected'),
      graph = $('#graph'+tab_idx),
      data = <%= @report.flot[:data].to_json %>;

  var series = [];
  for (loc in data)  {
    series.push({
      data: data[loc][sensors[tab_idx].key],
      label: loc
    });
  }

  var opts = {
    xaxis: {
      mode: 'time',
      zoomRange: <%= @report.flot[:zoom_range].to_json %>,
      panRange: <%= @report.flot[:pan_range].to_json %>
    },
    yaxis: {
      min: sensors[tab_idx].min_y,
      max: sensors[tab_idx].max_y,
      zoomRange: [sensors[tab_idx].max_y - sensors[tab_idx].min_y, sensors[tab_idx].max_y - sensors[tab_idx].min_y],
      panRange: [sensors[tab_idx].min_y, sensors[tab_idx].max_y]
    },
    grid: {
      color: $('.ui-widget-header').css('background-color'),
      hoverable: true
    },
    zoom: {
      interactive: true,
      beforeDraw: handleDynamicZoom
    },
    pan: {
      interactive: true
    },
    series: {
      lines: {show: true}
    }
  };

  global_plot = $.plot(graph, series, opts);
  graph.with_tooltips();

  function handleDynamicZoom() {
    //means: 'ignore zoom out as the very first zoom action'
    //otherwise, things go bonkers
    if (!this.getOptions().xaxis.max || !this.getOptions().xaxis.min) {
      return;
    }

    var xaxis_range = this.getOptions().xaxis.max - this.getOptions().xaxis.min,
        month = 1000*60*60*24*30,
        overview = sensors[tab_idx].key == 'overview';

    $.extend(true, this.getOptions().series, calculateSeriesOpts(this));
    
    this.setupGrid();//so that new ticks get generated

    if (overview) {
      //generate average per tick data
      var ticks = this.getAxes().xaxis.ticks,
          new_series = [];
      $.each(series, function(i, s) {
          new_series[i] = {
            label: s.label,
            data: [],
            bars: {align: i == 0 ? 'center' : 'left'}
          };
          $.each(ticks, function(j, v) {
              var prev_tick = ticks[j-1];
              if (prev_tick)  {
                new_series[i].data.push([v.v, avgY(s.data, prev_tick.v, v.v)]);
              }
          });
      });
      this.setData(new_series);
    }
    else  {
      this.setData(series);
    }

    function avgY(sdata, prev_tick, tick) {
      var ey = 0,
          q = 0;
      $.each(sdata, function(i, v) {
          if (v[0] > prev_tick && v[0] <= tick) {
            ey+= v[1];
            q++;
          }
      });
      return ey/q;
    }

    function calculateSeriesOpts(plot) {
      var points = {show: false},
          lines = {show: false},
          bars = {show: false};

      if (overview) {
        if (xaxis_range > month) {
          bars.show = true;
          bars.barWidth = xaxis_range/30;
        }
        else  {
          lines.show = true;
          points.show = true;
          points.radius = 3;
        }
      }
      else {
        lines.show = true;
        if (xaxis_range < 3*month && xaxis_range > month) {
          points.show = true;
          points.radius = 2;
        }
        else if (xaxis_range < month)  {
          points.show = true;
          points.radius = 3;
        }
      }
      return {points: points, lines: lines, bars: bars};
    }
  }
}

$.fn.extend({
  with_tooltips: function () {
    function showTooltip(x, y, contents) {
      $('<div id="tooltip">' + contents + '</div>').css( {
        position: 'absolute',
        display: 'none',
        top: y + 15,
        left: x + 15,
        opacity: 0.80
      }).addClass('ui-state-highlight').appendTo("body").fadeIn(200);
    }

    var previousPoint = null;
    this.bind("plothover", function (event, pos, item) {
      var tooltip = $('#tooltip');
      if (item) {
        if (previousPoint != item.datapoint) {
          previousPoint = item.datapoint;
          
          tooltip.remove();

          var label = /-|^0/.test(item.datapoint[1]) ? item.datapoint[1] : '+'+item.datapoint[1];
          showTooltip(item.pageX, item.pageY, label);
        }
      }
      else {
        tooltip.remove();
        previousPoint = null;            
      }
    });
  }
});


var sen_sel = $('#sensor_sel_tabs');
var sensors = <%= @report.flot[:sensors].to_json %>;
global_plot = null; //FIXME this is for accessing plot from firebug console. Remove after development is complete

if (!sen_sel.tabs('length'))  {// crafty check if tabs have already been initialized
  sen_sel.prepend('<ul></ul>').tabs();

  $.each(sensors, function(i, val) {
      var graph = $('<div id="graph'+i+'" class="flot-graph"/>');
      var graph_w = parseInt( /\d+/.exec(graph.css('width')) );
      var graph_h = parseInt( /\d+/.exec(graph.css('height')) );
      var graph_container = $('<div id="graph_cont'+i+'" style="width: '+ (graph_w + 30) +'px; height: '+ (graph_h + 20) +'px;"/>');
      graph_container.append(graph);
      sen_sel.append(graph_container).tabs('add', '#graph_cont'+i, val.name);
  });
  sen_sel.bind('tabsshow', function() {plotAsSelected()});
  sen_sel.tabs('select', 0);
}
plotAsSelected();

$('#loading').hide();
$('input.ui-widget').val('');

